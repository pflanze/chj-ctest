#!/usr/bin/env perl

my $copyright= <<'COPYRIGHT';
# Copyright 2021 by Christian Jaeger <ch@christianjaeger.ch>
# Published under the same terms as perl itself
COPYRIGHT

use strict;
use utf8;
use warnings;
use warnings FATAL => 'uninitialized';
use experimental 'signatures';

use Getopt::Long;
use Chj::xperlfunc qw(xgetfile_utf8 xprint xprintln);
use Chj::xIOUtil qw(xputfile_utf8);
#use FP::Repl::Trap; #

my ($email_full)= $copyright=~ / by ([^\n]*)/s;

my ($mydir, $myname);
BEGIN {
    $0=~ /(.*?)([^\/]+)\z/s or die "?";
    ($mydir, $myname)=($1,$2);
}

sub usage {
    print STDERR map{"$_\n"} @_ if @_;
    print "$myname target/foo.o ...

  Parses the .c and .h files it finds via the given .o files, prints
  make syntax of the dependencies.

  It also generates (overwrites) the file run_tests.c if
  target/run_tests.o is given.

  ($email_full)
";
exit (@_ ? 1 : 0);
}

our $verbose=0;
#our $opt_dry;
GetOptions("verbose"=> \$verbose,
	   "help"=> sub{usage},
	   #"dry-run"=> \$opt_dry,
	   ) or exit 1;
usage unless @ARGV;

sub o_to_perhaps_c ($path) {
    # returns () for .s files; exception if not found
    my $p = $path;
    $p=~ s/\.o$// or die "invalid object path '$path'";
    $p=~ s{^target/+}{} or die "invalid object path '$path'";
    my $c = "$p.c";
    if ($c eq "run_tests.c") {
        $c
    } elsif (-e $c) {
        $c
    } elsif (-e "$p.s") {
        ()
    } else {
        die "could not find $p.{c,s} for object path '$path'";
    }
}

package Dependency {
    use FP::Struct ["source", "dependency" ] => qw(FP::Struct::Show);
    _END_
}
Dependency::constructors->import();

sub line_to_perhaps_dep($line) {
    if (my ($path) = /^\s*#\s*include\s*"([^"]+)"/) {
        $path
    } else {
        ()
    }
}

sub chfile_dependencies ($path) {
    return () if $path eq "run_tests.c"; # hacky :/
    my @lines = split /\r?\n/, xgetfile_utf8($path);
    map {
        Dependency($path, $_)
    }
    map {
        line_to_perhaps_dep $_
    } @lines
}

my @c_files = map {
    o_to_perhaps_c $_
} @ARGV;

my $need_run_tests = exists +{ map {$_ => 1} @c_files }->{"run_tests.c"};

my @direct_deps = map { chfile_dependencies($_) } @c_files;

my %depends;

for (@direct_deps) {
    $depends{$_->source}->{$_->dependency}++;
}

sub add_missing {
    my %missing = map {
        exists $depends{$_} ? () : ($_=>1)
    } map {
        keys %$_
    } values %depends;

    my @deps = map { chfile_dependencies($_) } keys %missing;

    for (@deps) {
        $depends{$_->source}->{$_->dependency}++;
    }
    scalar @deps
}

do {} while add_missing;

sub printdeps_for($chfile, $seen) {
    my $d = $depends{$chfile} or return;
    # ^ OK, if foo.h has no includes then not here
    for my $chfile (sort keys %$d) {
        next if $seen->{$chfile};
        $seen->{$chfile}= 1;
        xprint " $chfile";
        printdeps_for($chfile, $seen);
    }
}

sub suffix($file) {
    $file=~ s/.*\.// or die "file does not have a suffix: '$file'";
    $file=~ /^\w+\z/ or die "bad suffix: '$file'";
    $file
}

for my $chfile (sort keys %depends) {
    if (suffix($chfile) eq 'c') {
        my $ofile = "target/$chfile";
        $ofile =~ s/\.c\z/.o/ or die "bug";
        xprint "$ofile:";
        # track down ALL dependencies; but only once each
        my $seen= {};
        printdeps_for($chfile, $seen);
        xprintln;
    }
}


sub line_to_perhaps_test($line) {
    if (my ($cfun) = /^\s*TEST\s*\(\s*(\w+)\s*\)\s*\{/) {
        $cfun
    } else {
        ()
    }
}

sub cfile_tests ($path) {
    my @lines = split /\r?\n/, xgetfile_utf8($path);
    map {
        # heh, bad naming but same principle of from => to mapping; pair??
        Dependency($path, $_)
    }
    map {
        line_to_perhaps_test $_
    } @lines
}

sub Dependency_filebasename($dep) {
    my $file = $dep->source;
    $file=~ s/\.c$//;
    $file=~ m{[/.]} and die "no support for paths currently: ".$dep->source;
    $file
}    

if ($need_run_tests) {
    # generate run_tests.c, from all the .c files except itself, with
    # all the given tests. Again does not parse CPP instructions that
    # might exclude them, d'oh, well. Assume all tests are used.
    my @tests = map {
        cfile_tests $_
    }
    grep { /\.c$/ and not $_ eq "run_tests.c" }
    sort keys %depends;

    xputfile_utf8(
        "run_tests.c",
        join "\n",
        "// generated by $0",
        '#include "test.h"',
        "",
        (
         map {
             my $fnname = $_->dependency;
             my $bn = Dependency_filebasename($_);
             "void __test_${bn}_$fnname (struct TestStatistics *);"
         } @tests
        ),
        "",
        "",
        "void run_tests() {",
        "    struct TestStatistics stats = { 0, 0 };",
        (
         map {
             my $fnname = $_->dependency;
             my $file = $_->source;
             my $bn = Dependency_filebasename($_);
             "    run_test_(\&stats, \"$fnname in \\\"$file\\\"\", __test_${bn}_$fnname);"
         } @tests
        ),
        "    print_teststatistics(\&stats);",
        "}",
        ""
        );
}

#use FP::Repl; repl;
#use Chj::ruse;
#use Chj::Backtrace; 

